{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { isFunction, isObject, retrieve2 } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../util/model.js';\n// Stored properties for further transition.\nexport var transitionStore = makeInner();\n/**\n * Return null if animation is disabled.\n */\nexport function getAnimationConfig(animationType, animatableModel, dataIndex,\n// Extra opts can override the option in animatable model.\nextraOpts,\n// TODO It's only for pictorial bar now.\nextraDelayParams) {\n  var animationPayload;\n  // Check if there is global animation configuration from dataZoom/resize can override the config in option.\n  // If animation is enabled. Will use this animation config in payload.\n  // If animation is disabled. Just ignore it.\n  if (animatableModel && animatableModel.ecModel) {\n    var updatePayload = animatableModel.ecModel.getUpdatePayload();\n    animationPayload = updatePayload && updatePayload.animation;\n  }\n  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n  var isUpdate = animationType === 'update';\n  if (animationEnabled) {\n    var duration = void 0;\n    var easing = void 0;\n    var delay = void 0;\n    if (extraOpts) {\n      duration = retrieve2(extraOpts.duration, 200);\n      easing = retrieve2(extraOpts.easing, 'cubicOut');\n      delay = 0;\n    } else {\n      duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');\n      easing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');\n      delay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');\n    }\n    // animation from payload has highest priority.\n    if (animationPayload) {\n      animationPayload.duration != null && (duration = animationPayload.duration);\n      animationPayload.easing != null && (easing = animationPayload.easing);\n      animationPayload.delay != null && (delay = animationPayload.delay);\n    }\n    if (isFunction(delay)) {\n      delay = delay(dataIndex, extraDelayParams);\n    }\n    if (isFunction(duration)) {\n      duration = duration(dataIndex);\n    }\n    var config = {\n      duration: duration || 0,\n      delay: delay,\n      easing: easing\n    };\n    return config;\n  } else {\n    return null;\n  }\n}\nfunction animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {\n  var isFrom = false;\n  var removeOpt;\n  if (isFunction(dataIndex)) {\n    during = cb;\n    cb = dataIndex;\n    dataIndex = null;\n  } else if (isObject(dataIndex)) {\n    cb = dataIndex.cb;\n    during = dataIndex.during;\n    isFrom = dataIndex.isFrom;\n    removeOpt = dataIndex.removeOpt;\n    dataIndex = dataIndex.dataIndex;\n  }\n  var isRemove = animationType === 'leave';\n  if (!isRemove) {\n    // Must stop the remove animation.\n    el.stopAnimation('leave');\n  }\n  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n  if (animationConfig && animationConfig.duration > 0) {\n    var duration = animationConfig.duration;\n    var animationDelay = animationConfig.delay;\n    var animationEasing = animationConfig.easing;\n    var animateConfig = {\n      duration: duration,\n      delay: animationDelay || 0,\n      easing: animationEasing,\n      done: cb,\n      force: !!cb || !!during,\n      // Set to final state in update/init animation.\n      // So the post processing based on the path shape can be done correctly.\n      setToFinal: !isRemove,\n      scope: animationType,\n      during: during\n    };\n    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);\n  } else {\n    el.stopAnimation();\n    // If `isFrom`, the props is the \"from\" props.\n    !isFrom && el.attr(props);\n    // Call during at least once.\n    during && during(1);\n    cb && cb();\n  }\n}\n/**\n * Update graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n * @example\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n *     // Or\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, function () { console.log('Animation done!'); });\n */\nfunction updateProps(el, props,\n// TODO: TYPE AnimatableModel\nanimatableModel, dataIndex, cb, during) {\n  animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);\n}\nexport { updateProps };\n/**\n * Init graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n */\nexport function initProps(el, props, animatableModel, dataIndex, cb, during) {\n  animateOrSetProps('enter', el, props, animatableModel, dataIndex, cb, during);\n}\n/**\n * If element is removed.\n * It can determine if element is having remove animation.\n */\nexport function isElementRemoved(el) {\n  if (!el.__zr) {\n    return true;\n  }\n  for (var i = 0; i < el.animators.length; i++) {\n    var animator = el.animators[i];\n    if (animator.scope === 'leave') {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Remove graphic element\n */\nexport function removeElement(el, props, animatableModel, dataIndex, cb, during) {\n  // Don't do remove animation twice.\n  if (isElementRemoved(el)) {\n    return;\n  }\n  animateOrSetProps('leave', el, props, animatableModel, dataIndex, cb, during);\n}\nfunction fadeOutDisplayable(el, animatableModel, dataIndex, done) {\n  el.removeTextContent();\n  el.removeTextGuideLine();\n  removeElement(el, {\n    style: {\n      opacity: 0\n    }\n  }, animatableModel, dataIndex, done);\n}\nexport function removeElementWithFadeOut(el, animatableModel, dataIndex) {\n  function doRemove() {\n    el.parent && el.parent.remove(el);\n  }\n  // Hide label and labelLine first\n  // TODO Also use fade out animation?\n  if (!el.isGroup) {\n    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);\n  } else {\n    el.traverse(function (disp) {\n      if (!disp.isGroup) {\n        // Can invoke doRemove multiple times.\n        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);\n      }\n    });\n  }\n}\n/**\n * Save old style for style transition in universalTransition module.\n * It's used when element will be reused in each render.\n * For chart like map, heatmap, which will always create new element.\n * We don't need to save this because universalTransition can get old style from the old element\n */\nexport function saveOldStyle(el) {\n  transitionStore(el).oldStyle = el.style;\n}\nexport function getOldStyle(el) {\n  return transitionStore(el).oldStyle;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}